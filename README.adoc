image:./img/header.jpg[]

= HunterX PDE (Personal Development Environment)

HunterX PDE is a personalized NeoVim distribution crafted to make programming much more comfortable while facilitating an in-depth understanding of IDE components at their fundamental level.

== âš¡ Requirements

* *Neovim* (Needs to be built with LuaJIT)
* *GCC*: For compiling treesitter languages in Linux
* *Zig Compiler*: For compiling treesitter languages in Windows
* *ripgrep*: For live grep
* *fd*: For Find Files

== ğŸš€ Quick Start

=== ğŸ§ Linux

* Dependency: *GCC*

[source,bash]
----
git clone https://github.com/MidHunterX/HunterX-PDE '~/.config/nvim' --depth 1 && nvim
----

=== ğŸªŸ Windows

* Dependency: *Zig Compiler*

[source,cmd]
----
git clone https://github.com/MidHunterX/HunterX-PDE %%localappdata\nvim --depth 1 && nvim
----

== What's Included?

.ğŸ“¦ Package Manager
[%collapsible]
====
[discrete]
=== ğŸ’¤ Lazy.nvim
Moved to **Lazy.nvim** from Packer as it is the best plugin manager currently.
[discrete]
==== Features
* ğŸ“¦ Manage all your Neovim plugins with a powerful UI
* ğŸš€ Fast startup times thanks to automatic caching and bytecode compilation
* ğŸ’¾ Partial clones instead of shallow clones
* ğŸ”Œ Automatic lazy-loading of Lua modules
* â³ Automatically install missing plugins before starting up Neovim
* ğŸ’ª Async execution for improved performance
* ğŸ› ï¸ No need to manually compile plugins
* ğŸ§ª Correct sequencing of dependencies
* ğŸ“ Configurable in multiple files
* ğŸ“š Generates helptags of the headings in README.md files for plugins
* ğŸ’» Dev options and patterns for using local plugins
* ğŸ“Š Profiling tools to optimize performance
* ğŸ”’ Lockfile lazy-lock.json to keep track of installed plugins
* ğŸ” Automatically check for updates
* ğŸ“‹ Commit, branch, tag, version, and full Semver support
* ğŸ“ˆ Statusline component to see the number of pending updates
* ğŸ¨ Automatically lazy-loads colorschemes
====

=== ğŸ›º Auto Commands
* Tab space = 4 on C, CPP, C#, Python, Java
* Tab space = 2 on Every other Languages
* Use System Clipboard by Default
* Highlight Yank for 150ms
* Ability to scroll past EOF in buffer
* Automatically toggle between Relative Line Number based on Modes

=== ğŸ›‚ Custom Functions
* Toggle Boolean Values with `C-a`
* Trim trailing lines and Write Buffer with `<leader>w`
* Git add . + commit -m with `<leader>gc` (Replaced with Lazygit)
* Execute files with `F5` or `:lua Execute_order_69()`
* Run file formatter with `<leader>fm` or `:lua Run_formatter()`

=== ğŸ‘Š Hit Font
* Convert text to Hit Font with `:HitComment`

=== ğŸ—ºï¸ Remaps

==== Normal Mode

[%header]
|===
| Key          | Description
| `u`          | Undo
| `U`          | Redo
| `H`          | Move cursor to start `^` of a line
| `L`          | Move cursor to end `$` of a line
| `<C-u>`      | Scroll Half page up with Cursor centered
| `<C-d>`      | Scroll Half page down with Cursor centered
| `<A-h>`      | Go to Previous Buffer
| `<A-l>`      | Go to Next Buffer
| `<Space>`    | Leader Key
| `<leader>rr` | Replace word under cursor with Regex
| `<leader>x`  | Delete Current Buffer
| `<leader>d`  | Deletes selection into blackhole register
| `<leader>p`  | Deletes selection into blackhole register and paste
| `ghh`        | Git Preview Hunk
| `ghn`        | Git Next Hunk
| `ghp`        | Git Previous Hunk
|===

==== Visual Mode

[%header]
|===
| Key       | Description
| `<Space>` | Leader
| `J`       | Move line Down with autoindent
| `K`       | Move line Up with autoindent
| `<`       | Indent line/selection to Left
| `>`       | Indent line/selection to Right
| `H`       | Move cursor to start `^` of a line
| `L`       | Move cursor to end `$` of a line
|===

==== Terminal Mode

[%header]
|===
| Key      | Description
| `<C-w>n` | Return to Normal Mode
|===

=== ğŸ¦… Code Navigation (aerial.nvim)

[%header]
|===
| Key             | Description
| `<leader>pv`    | Toggle Aerial View
| `i`             | Jump to selected Function/Method
| `x`             | Exit from Aerial View
| `q`             | Exit from Aerial View
| ---             | ---
| `?`             | show_help
| `<CR>`          | jump
| `<C-v>`         | jump_vsplit
| `<C-s>`         | jump_split
| `p`             | scroll
| `<C-j>`         | down_and_scroll
| `<C-k>`         | up_and_scroll
| `{`             | prev
| `}`             | next
| `[[`            | prev_up
| `]]`            | next_up
| `o`             | tree_toggle
| `O`             | tree_toggle_recursive
| `l`             | tree_open
| `L`             | tree_open_recursive
| `h`             | tree_close
| `H`             | tree_close_recursive
|===

=== ğŸ•ºğŸ’ƒ Bracket Auto Pairs (nvim-autopairs)

Autocloses these Brackets and Quotes: '{', '[', '(', '"', '\''

=== ğŸª¨ Auto Disable Features on Big Files (bigfile.nvim)

Automatically disables certain features if the opened file is big (1MB).

Disabled Features: `indent_blankline`, `illuminate`, `lsp`, `treesitter`,
         `syntax`, `vimopts`, `filetype`

=== ğŸ¨ Colorschemes

The following colorschemes are included:

* `VSCode`
* `OneDarkPro`
* `Catppuccin`

To change colorscheme, do `:colorscheme` and a space to trigger autocompletion

=== ğŸ± Dashboard (dashboard-nvim)

Low memory usage. dashboard does not store the all user configs in memory like
header etc these string will take some memory. now it will be clean after you
open a file. you can still use dashboard command to open a new one , then
dashboard will read the config from cache.

[%header]
|===
| Key | Description
| `x` | Netrw
| `f` | Fuzzy Find Files with Telescope
| `g` | Grep Search Strings with Telescope
| `r` | Print a Random number between 1-999
|===

=== â™ Gitsigns on Gutter (gitsigns.nvim)

[%header]
|===
| Hunk Actions | Line Blame
| image:https://raw.githubusercontent.com/lewis6991/media/main/gitsigns_actions.gif[]
| image:https://raw.githubusercontent.com/lewis6991/media/main/gitsigns_blame.gif[]
|===

Features:

* Signs for added, removed, and changed lines
* Asynchronous
* Navigation between hunks
* Preview diffs of hunks (with word diff)
* Status bar integration
* Git blame a specific line using virtual text.
* Hunk text object
* Ability to display deleted/changed lines via virtual lines.

=== ğŸ”§ Language Server Protocol

A language server is a specific kind of tool. Usually they are command line
tools that implement the LSP specification. Long story short, the language
server analyzes the source code in your project and tells the editor what to
do.

mason.nvim and mason-lspconfig.nvim manages the installation of the language
servers from inside Neovim, and then lspconfig to configure the language
servers.

==== ğŸ”¨ LSP Manager (mason.nvim)

Portable package manager for Neovim to easily install and manage LSP servers,
DAP servers, linters, and formatters.

mason.nvim is a Neovim plugin that allows you to easily manage external editor
tooling such as LSP servers, DAP servers, linters, and formatters through a
single interface. It runs everywhere Neovim runs (across Linux, macOS, Windows,
etc.), with only a small set of external requirements needed.

==== ğŸ“ LSP Server Auto Configuration (nvim-lspconfig)

Language servers are configured and initialized using `nvim-lspconfig`.
"Capablities" comes from `cmp-nvim-lsp`. It tells the language server what
features `nvim-cmp` adds to the editor.

Then it creates an autocommand on the event LspAttach. This autocommand will be
triggered every time a language server is attached to a buffer. This is where
all keybindings and commands are created.

Here, I have implemented the following autocompletion behaviour:

* Autocompletion suggestions keep popping while typing
* If the suggestion box is visible, you can do the following
* Select Next entries with: `TAB`, `C-n`
* Select Previous entries with: `S-TAB`, `C-p`
* Accept an entry with `CR` / `RET`

ğŸ¤” Maybe VSCode like `DOWN` to select and `TAB` to complete might be better?

==== ğŸƒ Code Auto Completion (nvim-cmp)

The following Auto completion are available:

* Commandline Autocompletion `:`
* System Path Autocompletion `./`
* Buffer Text based Autocompletion
* Snippet based Autocompletion
* LSP based Autocompletion

==== ğŸš’ Code Snippet Engine (luasnip)

Features:

* Tabstops
* Text-Transformations using Lua functions
* Conditional Expansion
* Defining nested Snippets
* Filetype-specific Snippets
* Choices
* Dynamic Snippet creation
* Regex-Trigger
* Autotriggered Snippets
* Easy Postfix Snippets
* Parse LSP-Style Snippets directly in lua as a vscode package
* Expand LSP-Snippets with nvim-cmp (requires cmp_luasnip)
* Snippet history (jump back into older snippets)
* Resolve filetype at the cursor using Treesitter

=== Extra Packages

* Scope based Indentation Lines
* Lazygit Integration
* Leap Cursor Navigation
* Colored Matching Brackets
* Status Line
* Surrounding Brackets/Quotes as Text Objects
* Tab out of Brackets/Quotes
* Telescope (Fuzzyfind & Grep)
* Undotree
* Color Picker
* Treesitter
* Treesitter Contexts
* Treesitter Playground
* Treesitter Text Objects
* VIFM File Explorer
* Visible Color Codes
* Zen Mode

=== Added Text Objects

[%header]
|===
| Old Text Objects | Description
| P                | Paragraph
| W                | Word
| " ' `` ' "       | Strings
| [ { ( ) } ]      | Brackets
| T                | Markup Tags
|===

[%header]
|===
| New Text Objects | Description
| I                | Conditional
| L                | Loop
| F                | Function
| M                | Method
| C                | Class
| A                | Argument
| =                | Assignment
| :                | Propery
|===

